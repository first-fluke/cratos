//! Skill CLI commands
//!
//! `cratos skill` - List, show, enable, and disable skills

use super::SkillCommands;
use anyhow::{Context, Result};
use chrono::Utc;
use cratos_skills::{RemoteRegistry, Skill, SkillEcosystem, SkillStatus, SkillStore};

/// Status indicator for active skill
const ICON_ACTIVE: &str = "\u{1f7e2}"; // ðŸŸ¢
/// Status indicator for inactive/disabled/draft skill
const ICON_INACTIVE: &str = "\u{1f534}"; // ðŸ”´

/// Run skill command
pub async fn run(cmd: SkillCommands) -> Result<()> {
    let store = open_store().await?;

    match cmd {
        SkillCommands::List { active } => list(&store, active).await,
        SkillCommands::Show { name } => show(&store, &name).await,
        SkillCommands::Enable { name } => enable(&store, &name).await,
        SkillCommands::Disable { name } => disable(&store, &name).await,
        SkillCommands::Export { name, output } => export_skill(&store, &name, output).await,
        SkillCommands::Import { path } => import_skill(&store, &path).await,
        SkillCommands::Bundle { name, output } => export_bundle(&store, &name, output).await,
        SkillCommands::Search { query, registry } => search_remote(&query, registry).await,
        SkillCommands::Install { name, registry } => install_remote(&store, &name, registry).await,
        SkillCommands::Publish { name, token, registry } => {
            publish_remote(&store, &name, token, registry).await
        }
    }
}

/// Open the default skill store
async fn open_store() -> Result<SkillStore> {
    let db_path = cratos_skills::default_skill_db_path();
    SkillStore::from_path(&db_path)
        .await
        .context("Failed to open skill store")
}

/// List skills
async fn list(store: &SkillStore, active_only: bool) -> Result<()> {
    let skills = if active_only {
        store.list_active_skills().await
    } else {
        store.list_skills().await
    }
    .context("Failed to list skills")?;

    let active_count = skills.iter().filter(|s| s.is_active()).count();
    let total = skills.len();

    if skills.is_empty() {
        println!("\nNo skills found.");
        println!("Skills are auto-generated from usage patterns or created manually.\n");
        return Ok(());
    }

    let filter_label = if active_only { " (active only)" } else { "" };
    println!(
        "\nCratos Skills ({} total, {} active){}\n{}",
        total,
        active_count,
        filter_label,
        "-".repeat(56)
    );

    for skill in &skills {
        let icon = status_icon(skill.status);
        let origin_label = match skill.origin {
            cratos_skills::SkillOrigin::AutoGenerated => "auto",
            cratos_skills::SkillOrigin::UserDefined => "user",
            cratos_skills::SkillOrigin::Builtin => "built",
        };
        let rate = format_rate(skill.metadata.success_rate, skill.metadata.usage_count);
        let ago = skill
            .metadata
            .last_used_at
            .map(format_duration_since)
            .unwrap_or_else(|| "never".to_string());
        let disabled_tag = if skill.status == SkillStatus::Disabled {
            " [disabled]"
        } else if skill.status == SkillStatus::Draft {
            " [draft]"
        } else {
            ""
        };

        println!(
            "  {} {:<26} {:<10} {:<6} {:<14} {}{}",
            icon, skill.name, skill.category, origin_label, rate, ago, disabled_tag,
        );
    }

    println!();
    Ok(())
}

/// Show skill details
async fn show(store: &SkillStore, name: &str) -> Result<()> {
    let skill = store
        .get_skill_by_name(name)
        .await
        .context("Failed to query skill")?;

    match skill {
        Some(skill) => print_skill_detail(&skill, store).await,
        None => {
            println!("\nSkill not found: {name}");
            println!("Run `cratos skill list` to see available skills.\n");
            Ok(())
        }
    }
}

/// Print detailed skill information
async fn print_skill_detail(skill: &Skill, store: &SkillStore) -> Result<()> {
    let icon = status_icon(skill.status);
    let status_label = match skill.status {
        SkillStatus::Active => "Active",
        SkillStatus::Disabled => "Disabled",
        SkillStatus::Draft => "Draft",
    };

    println!("\nSkill: {}\n", skill.name);
    println!("  Status:     {} {}", icon, status_label);
    println!("  Category:   {}", skill.category);
    println!("  Origin:     {}", skill.origin);

    // Triggers
    if !skill.trigger.keywords.is_empty()
        || !skill.trigger.intents.is_empty()
        || !skill.trigger.regex_patterns.is_empty()
    {
        println!("\n  Triggers:");
        if !skill.trigger.keywords.is_empty() {
            println!("    Keywords: {}", skill.trigger.keywords.join(", "));
        }
        if !skill.trigger.intents.is_empty() {
            println!("    Intents:  {}", skill.trigger.intents.join(", "));
        }
        if !skill.trigger.regex_patterns.is_empty() {
            println!("    Patterns: {}", skill.trigger.regex_patterns.join(", "));
        }
    }

    // Steps
    if !skill.steps.is_empty() {
        println!("\n  Steps:");
        for step in &skill.steps {
            let on_err = format!("[{} on error]", step.on_error);
            let input_preview = serde_json::to_string(&step.input_template)
                .unwrap_or_else(|_| "{}".to_string());
            // Truncate long input previews safely
            let input_short = truncate_str(&input_preview, 40);
            println!(
                "    {}. {:<14} {} {}",
                step.order, step.tool_name, input_short, on_err
            );
        }
    }

    // Metrics
    let (total, successes) = store
        .get_skill_execution_count(skill.id)
        .await
        .unwrap_or((0, 0));
    let rate_pct = if total > 0 {
        (successes as f64 / total as f64) * 100.0
    } else {
        skill.metadata.success_rate * 100.0
    };

    println!("\n  Metrics:");
    println!("    Usage:        {} executions", skill.metadata.usage_count);
    println!(
        "    Success rate: {:.1}% ({}/{})",
        rate_pct, successes, total
    );
    if let Some(avg_ms) = skill.metadata.avg_duration_ms {
        let avg_secs = avg_ms as f64 / 1000.0;
        println!("    Avg duration: {avg_secs:.1}s");
    }
    let last_used = skill
        .metadata
        .last_used_at
        .map(format_duration_since)
        .unwrap_or_else(|| "never".to_string());
    println!("    Last used:    {last_used}");

    println!();
    Ok(())
}

/// Enable a skill (set status to Active)
async fn enable(store: &SkillStore, name: &str) -> Result<()> {
    let skill = store
        .get_skill_by_name(name)
        .await
        .context("Failed to query skill")?;

    match skill {
        Some(mut skill) => {
            if skill.is_active() {
                println!("Skill '{name}' is already active.");
            } else {
                skill.activate();
                store
                    .save_skill(&skill)
                    .await
                    .context("Failed to save skill")?;
                println!("{ICON_ACTIVE} Skill '{name}' enabled.");
            }
            Ok(())
        }
        None => {
            println!("Skill not found: {name}");
            println!("Run `cratos skill list` to see available skills.");
            Ok(())
        }
    }
}

/// Disable a skill
async fn disable(store: &SkillStore, name: &str) -> Result<()> {
    let skill = store
        .get_skill_by_name(name)
        .await
        .context("Failed to query skill")?;

    match skill {
        Some(mut skill) => {
            if skill.status == SkillStatus::Disabled {
                println!("Skill '{name}' is already disabled.");
            } else {
                skill.disable();
                store
                    .save_skill(&skill)
                    .await
                    .context("Failed to save skill")?;
                println!("{ICON_INACTIVE} Skill '{name}' disabled.");
            }
            Ok(())
        }
        None => {
            println!("Skill not found: {name}");
            println!("Run `cratos skill list` to see available skills.");
            Ok(())
        }
    }
}

/// Export a skill to a JSON file
async fn export_skill(store: &SkillStore, name: &str, output: Option<String>) -> Result<()> {
    let eco = SkillEcosystem::new(store.clone());
    let portable = eco
        .export_skill_by_name(name)
        .await
        .context("Failed to export skill")?;

    let output_path = output.unwrap_or_else(|| format!("{}.skill.json", name));
    let json = serde_json::to_string_pretty(&portable).context("Failed to serialize skill")?;
    std::fs::write(&output_path, json).context("Failed to write file")?;

    println!("Exported skill '{}' to {}", name, output_path);
    Ok(())
}

/// Import a skill from a JSON file
async fn import_skill(store: &SkillStore, path: &str) -> Result<()> {
    let eco = SkillEcosystem::new(store.clone());
    let file_path = std::path::Path::new(path);

    if path.ends_with(".bundle.json") {
        let results = eco
            .import_bundle_from_file(file_path)
            .await
            .context("Failed to import bundle")?;
        let new_count = results.iter().filter(|r| r.is_new).count();
        let updated = results.len() - new_count;
        println!(
            "Bundle import: {} new, {} updated",
            new_count, updated
        );
        for r in &results {
            let status = if r.is_new { "new" } else { "updated" };
            println!("  {} {}", status, r.skill.name);
        }
    } else {
        let result = eco
            .import_from_file(file_path)
            .await
            .context("Failed to import skill")?;
        let status = if result.is_new { "Imported" } else { "Updated" };
        println!("{} skill: {}", status, result.skill.name);
        for warning in &result.warnings {
            println!("  Warning: {}", warning);
        }
    }
    Ok(())
}

/// Export all active skills as a bundle
async fn export_bundle(store: &SkillStore, name: &str, output: Option<String>) -> Result<()> {
    let eco = SkillEcosystem::new(store.clone());
    let bundle = eco
        .export_bundle(name, &format!("Cratos skill bundle: {}", name))
        .await
        .context("Failed to export bundle")?;

    let output_path = output.unwrap_or_else(|| format!("{}.skill.bundle.json", name));
    let json = serde_json::to_string_pretty(&bundle).context("Failed to serialize bundle")?;
    std::fs::write(&output_path, json).context("Failed to write file")?;

    println!(
        "Exported {} skills to {}",
        bundle.skills.len(),
        output_path
    );
    Ok(())
}

// â”€â”€â”€ Remote registry commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/// Search remote skill registry
async fn search_remote(query: &str, registry: Option<String>) -> Result<()> {
    let reg = match registry {
        Some(url) => RemoteRegistry::new(&url),
        None => RemoteRegistry::default_registry(),
    };

    let results = reg
        .search(query)
        .await
        .context("Failed to search remote registry")?;

    if results.is_empty() {
        println!("\nNo skills found matching '{query}'.");
        return Ok(());
    }

    println!(
        "\nRemote Skills matching '{}' ({} found)\n{}",
        query,
        results.len(),
        "-".repeat(60)
    );

    for entry in &results {
        println!(
            "  {:<24} v{:<8} {:<10} by {}",
            entry.name, entry.version, entry.category, entry.author
        );
        println!("    {}", entry.description);
    }
    println!();

    Ok(())
}

/// Install a skill from remote registry
async fn install_remote(store: &SkillStore, name: &str, registry: Option<String>) -> Result<()> {
    let reg = match registry {
        Some(url) => RemoteRegistry::new(&url),
        None => RemoteRegistry::default_registry(),
    };

    println!("Fetching skill '{}' from registry...", name);

    let portable = reg
        .fetch_skill(name)
        .await
        .context("Failed to fetch skill from registry")?;

    let eco = SkillEcosystem::new(store.clone());
    let result = eco
        .import_skill(&portable)
        .await
        .context("Failed to import skill")?;

    let status = if result.is_new { "Installed" } else { "Updated" };
    println!("{} skill: {}", status, result.skill.name);
    for warning in &result.warnings {
        println!("  Warning: {}", warning);
    }

    Ok(())
}

/// Publish a skill to remote registry
async fn publish_remote(
    store: &SkillStore,
    name: &str,
    token: Option<String>,
    registry: Option<String>,
) -> Result<()> {
    let token = match token {
        Some(t) => t,
        None => {
            return Err(anyhow::anyhow!(
                "Registry token required. Use --token <TOKEN> or set CRATOS_REGISTRY_TOKEN."
            ));
        }
    };

    let eco = SkillEcosystem::new(store.clone());
    let portable = eco
        .export_skill_by_name(name)
        .await
        .context("Failed to export skill")?;

    let reg = match registry {
        Some(url) => RemoteRegistry::new(&url),
        None => RemoteRegistry::default_registry(),
    };

    println!("Publishing skill '{}' to registry...", name);

    reg.publish(&portable, &token)
        .await
        .context("Failed to publish skill")?;

    println!("Skill '{}' published successfully.", name);
    Ok(())
}

// â”€â”€â”€ Helper functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/// Return status icon for a skill status
fn status_icon(status: SkillStatus) -> &'static str {
    match status {
        SkillStatus::Active => ICON_ACTIVE,
        SkillStatus::Disabled | SkillStatus::Draft => ICON_INACTIVE,
    }
}

/// Format success rate as "XX.X% (N/M)"
fn format_rate(rate: f64, usage: u64) -> String {
    if usage == 0 {
        return "-- (0/0)".to_string();
    }
    let successes = (rate * usage as f64).round() as u64;
    format!("{:.1}% ({}/{})", rate * 100.0, successes, usage)
}

/// Format a duration since a timestamp (e.g., "2h ago", "3d ago")
fn format_duration_since(timestamp: chrono::DateTime<Utc>) -> String {
    let elapsed = Utc::now().signed_duration_since(timestamp);
    let secs = elapsed.num_seconds();

    if secs < 0 {
        return "just now".to_string();
    }

    let minutes = secs / 60;
    let hours = minutes / 60;
    let days = hours / 24;

    if days > 0 {
        format!("{days}d ago")
    } else if hours > 0 {
        format!("{hours}h ago")
    } else if minutes > 0 {
        format!("{minutes}m ago")
    } else {
        "just now".to_string()
    }
}

/// Safely truncate a string, respecting UTF-8 char boundaries
fn truncate_str(s: &str, max_len: usize) -> String {
    if s.len() <= max_len {
        return s.to_string();
    }
    let end = s
        .char_indices()
        .take_while(|(i, _)| *i < max_len.saturating_sub(3))
        .last()
        .map(|(i, c)| i + c.len_utf8())
        .unwrap_or(0);
    format!("{}...", &s[..end])
}
