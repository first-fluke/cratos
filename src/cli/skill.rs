//! Skill CLI commands
//!
//! `cratos skill` - List, show, enable, and disable skills

use super::SkillCommands;
use anyhow::{Context, Result};
use chrono::Utc;
use cratos_skills::{Skill, SkillStatus, SkillStore};

/// Status indicator for active skill
const ICON_ACTIVE: &str = "\u{1f7e2}"; // ðŸŸ¢
/// Status indicator for inactive/disabled/draft skill
const ICON_INACTIVE: &str = "\u{1f534}"; // ðŸ”´

/// Run skill command
pub async fn run(cmd: SkillCommands) -> Result<()> {
    let store = open_store().await?;

    match cmd {
        SkillCommands::List { active } => list(&store, active).await,
        SkillCommands::Show { name } => show(&store, &name).await,
        SkillCommands::Enable { name } => enable(&store, &name).await,
        SkillCommands::Disable { name } => disable(&store, &name).await,
    }
}

/// Open the default skill store
async fn open_store() -> Result<SkillStore> {
    let db_path = cratos_skills::default_skill_db_path();
    SkillStore::from_path(&db_path)
        .await
        .context("Failed to open skill store")
}

/// List skills
async fn list(store: &SkillStore, active_only: bool) -> Result<()> {
    let skills = if active_only {
        store.list_active_skills().await
    } else {
        store.list_skills().await
    }
    .context("Failed to list skills")?;

    let active_count = skills.iter().filter(|s| s.is_active()).count();
    let total = skills.len();

    if skills.is_empty() {
        println!("\nNo skills found.");
        println!("Skills are auto-generated from usage patterns or created manually.\n");
        return Ok(());
    }

    let filter_label = if active_only { " (active only)" } else { "" };
    println!(
        "\nCratos Skills ({} total, {} active){}\n{}",
        total,
        active_count,
        filter_label,
        "-".repeat(56)
    );

    for skill in &skills {
        let icon = status_icon(skill.status);
        let origin_label = match skill.origin {
            cratos_skills::SkillOrigin::AutoGenerated => "auto",
            cratos_skills::SkillOrigin::UserDefined => "user",
            cratos_skills::SkillOrigin::Builtin => "built",
        };
        let rate = format_rate(skill.metadata.success_rate, skill.metadata.usage_count);
        let ago = skill
            .metadata
            .last_used_at
            .map(format_duration_since)
            .unwrap_or_else(|| "never".to_string());
        let disabled_tag = if skill.status == SkillStatus::Disabled {
            " [disabled]"
        } else if skill.status == SkillStatus::Draft {
            " [draft]"
        } else {
            ""
        };

        println!(
            "  {} {:<26} {:<10} {:<6} {:<14} {}{}",
            icon, skill.name, skill.category, origin_label, rate, ago, disabled_tag,
        );
    }

    println!();
    Ok(())
}

/// Show skill details
async fn show(store: &SkillStore, name: &str) -> Result<()> {
    let skill = store
        .get_skill_by_name(name)
        .await
        .context("Failed to query skill")?;

    match skill {
        Some(skill) => print_skill_detail(&skill, store).await,
        None => {
            println!("\nSkill not found: {name}");
            println!("Run `cratos skill list` to see available skills.\n");
            Ok(())
        }
    }
}

/// Print detailed skill information
async fn print_skill_detail(skill: &Skill, store: &SkillStore) -> Result<()> {
    let icon = status_icon(skill.status);
    let status_label = match skill.status {
        SkillStatus::Active => "Active",
        SkillStatus::Disabled => "Disabled",
        SkillStatus::Draft => "Draft",
    };

    println!("\nSkill: {}\n", skill.name);
    println!("  Status:     {} {}", icon, status_label);
    println!("  Category:   {}", skill.category);
    println!("  Origin:     {}", skill.origin);

    // Triggers
    if !skill.trigger.keywords.is_empty()
        || !skill.trigger.intents.is_empty()
        || !skill.trigger.regex_patterns.is_empty()
    {
        println!("\n  Triggers:");
        if !skill.trigger.keywords.is_empty() {
            println!("    Keywords: {}", skill.trigger.keywords.join(", "));
        }
        if !skill.trigger.intents.is_empty() {
            println!("    Intents:  {}", skill.trigger.intents.join(", "));
        }
        if !skill.trigger.regex_patterns.is_empty() {
            println!("    Patterns: {}", skill.trigger.regex_patterns.join(", "));
        }
    }

    // Steps
    if !skill.steps.is_empty() {
        println!("\n  Steps:");
        for step in &skill.steps {
            let on_err = format!("[{} on error]", step.on_error);
            let input_preview = serde_json::to_string(&step.input_template)
                .unwrap_or_else(|_| "{}".to_string());
            // Truncate long input previews safely
            let input_short = truncate_str(&input_preview, 40);
            println!(
                "    {}. {:<14} {} {}",
                step.order, step.tool_name, input_short, on_err
            );
        }
    }

    // Metrics
    let (total, successes) = store
        .get_skill_execution_count(skill.id)
        .await
        .unwrap_or((0, 0));
    let rate_pct = if total > 0 {
        (successes as f64 / total as f64) * 100.0
    } else {
        skill.metadata.success_rate * 100.0
    };

    println!("\n  Metrics:");
    println!("    Usage:        {} executions", skill.metadata.usage_count);
    println!(
        "    Success rate: {:.1}% ({}/{})",
        rate_pct, successes, total
    );
    if let Some(avg_ms) = skill.metadata.avg_duration_ms {
        let avg_secs = avg_ms as f64 / 1000.0;
        println!("    Avg duration: {avg_secs:.1}s");
    }
    let last_used = skill
        .metadata
        .last_used_at
        .map(format_duration_since)
        .unwrap_or_else(|| "never".to_string());
    println!("    Last used:    {last_used}");

    println!();
    Ok(())
}

/// Enable a skill (set status to Active)
async fn enable(store: &SkillStore, name: &str) -> Result<()> {
    let skill = store
        .get_skill_by_name(name)
        .await
        .context("Failed to query skill")?;

    match skill {
        Some(mut skill) => {
            if skill.is_active() {
                println!("Skill '{name}' is already active.");
            } else {
                skill.activate();
                store
                    .save_skill(&skill)
                    .await
                    .context("Failed to save skill")?;
                println!("{ICON_ACTIVE} Skill '{name}' enabled.");
            }
            Ok(())
        }
        None => {
            println!("Skill not found: {name}");
            println!("Run `cratos skill list` to see available skills.");
            Ok(())
        }
    }
}

/// Disable a skill
async fn disable(store: &SkillStore, name: &str) -> Result<()> {
    let skill = store
        .get_skill_by_name(name)
        .await
        .context("Failed to query skill")?;

    match skill {
        Some(mut skill) => {
            if skill.status == SkillStatus::Disabled {
                println!("Skill '{name}' is already disabled.");
            } else {
                skill.disable();
                store
                    .save_skill(&skill)
                    .await
                    .context("Failed to save skill")?;
                println!("{ICON_INACTIVE} Skill '{name}' disabled.");
            }
            Ok(())
        }
        None => {
            println!("Skill not found: {name}");
            println!("Run `cratos skill list` to see available skills.");
            Ok(())
        }
    }
}

// â”€â”€â”€ Helper functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/// Return status icon for a skill status
fn status_icon(status: SkillStatus) -> &'static str {
    match status {
        SkillStatus::Active => ICON_ACTIVE,
        SkillStatus::Disabled | SkillStatus::Draft => ICON_INACTIVE,
    }
}

/// Format success rate as "XX.X% (N/M)"
fn format_rate(rate: f64, usage: u64) -> String {
    if usage == 0 {
        return "-- (0/0)".to_string();
    }
    let successes = (rate * usage as f64).round() as u64;
    format!("{:.1}% ({}/{})", rate * 100.0, successes, usage)
}

/// Format a duration since a timestamp (e.g., "2h ago", "3d ago")
fn format_duration_since(timestamp: chrono::DateTime<Utc>) -> String {
    let elapsed = Utc::now().signed_duration_since(timestamp);
    let secs = elapsed.num_seconds();

    if secs < 0 {
        return "just now".to_string();
    }

    let minutes = secs / 60;
    let hours = minutes / 60;
    let days = hours / 24;

    if days > 0 {
        format!("{days}d ago")
    } else if hours > 0 {
        format!("{hours}h ago")
    } else if minutes > 0 {
        format!("{minutes}m ago")
    } else {
        "just now".to_string()
    }
}

/// Safely truncate a string, respecting UTF-8 char boundaries
fn truncate_str(s: &str, max_len: usize) -> String {
    if s.len() <= max_len {
        return s.to_string();
    }
    let end = s
        .char_indices()
        .take_while(|(i, _)| *i < max_len.saturating_sub(3))
        .last()
        .map(|(i, c)| i + c.len_utf8())
        .unwrap_or(0);
    format!("{}...", &s[..end])
}
