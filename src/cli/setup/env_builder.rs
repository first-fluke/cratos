//! Build and write the .env configuration file.

use super::providers::Provider;

/// Parameters for building the .env file.
pub struct EnvParams<'a> {
    pub provider: &'a Provider,
    pub api_key: &'a str,
    pub fallback_provider: Option<&'a Provider>,
    pub fallback_key: &'a str,
    pub telegram_token: &'a str,
    pub slack_token: &'a str,
    pub slack_secret: &'a str,
    pub discord_token: &'a str,
    pub persona: &'a str,
}

pub fn build_env(p: &EnvParams<'_>) -> String {
    let mut c = String::from("# Cratos Environment Variables\n");
    c.push_str("# Generated by cratos init\n\n");

    // LLM Provider
    c.push_str("# ===================\n");
    c.push_str("# LLM Provider\n");
    c.push_str("# ===================\n");
    if p.provider.name == "ollama" {
        c.push_str("OLLAMA_BASE_URL=http://localhost:11434\n");
    } else if p.api_key.is_empty() {
        c.push_str(&format!(
            "# {}=  (using CLI subscription auth)\n",
            p.provider.env_var
        ));
    } else {
        c.push_str(&format!("{}={}\n", p.provider.env_var, p.api_key));
    }
    c.push_str(&format!(
        "CRATOS_LLM__DEFAULT_PROVIDER={}\n",
        p.provider.name
    ));

    // Fallback Provider
    if let Some(fb) = p.fallback_provider {
        c.push_str("\n# ===================\n");
        c.push_str("# Fallback Provider\n");
        c.push_str("# ===================\n");
        if !p.fallback_key.is_empty() && fb.name != "ollama" {
            c.push_str(&format!("{}={}\n", fb.env_var, p.fallback_key));
        }
        c.push_str(&format!("CRATOS_LLM__FALLBACK_PROVIDER={}\n", fb.name));
    }

    // Default Persona
    c.push_str("\n# ===================\n");
    c.push_str("# Default Persona\n");
    c.push_str("# ===================\n");
    c.push_str(&format!("CRATOS_DEFAULT_PERSONA={}\n", p.persona));

    // Telegram
    c.push_str("\n# ===================\n");
    c.push_str("# Telegram\n");
    c.push_str("# ===================\n");
    if p.telegram_token.is_empty() {
        c.push_str("# TELEGRAM_BOT_TOKEN=your-telegram-bot-token\n");
    } else {
        c.push_str(&format!("TELEGRAM_BOT_TOKEN={}\n", p.telegram_token));
    }

    // Slack
    c.push_str("\n# ===================\n");
    c.push_str("# Slack\n");
    c.push_str("# ===================\n");
    if p.slack_token.is_empty() {
        c.push_str("# SLACK_BOT_TOKEN=xoxb-your-slack-bot-token\n");
        c.push_str("# SLACK_SIGNING_SECRET=your-slack-signing-secret\n");
    } else {
        c.push_str(&format!("SLACK_BOT_TOKEN={}\n", p.slack_token));
        c.push_str(&format!("SLACK_SIGNING_SECRET={}\n", p.slack_secret));
    }

    // Discord
    c.push_str("\n# ===================\n");
    c.push_str("# Discord\n");
    c.push_str("# ===================\n");
    if p.discord_token.is_empty() {
        c.push_str("# DISCORD_BOT_TOKEN=your-discord-bot-token\n");
    } else {
        c.push_str(&format!("DISCORD_BOT_TOKEN={}\n", p.discord_token));
    }

    // Server
    c.push_str("\n# ===================\n");
    c.push_str("# Server\n");
    c.push_str("# ===================\n");
    c.push_str("HOST=127.0.0.1\n");
    c.push_str("PORT=19527\n");

    // Logging
    c.push_str("\n# ===================\n");
    c.push_str("# Logging\n");
    c.push_str("# ===================\n");
    c.push_str("RUST_LOG=cratos=info,tower_http=info\n");

    c
}
