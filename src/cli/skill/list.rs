use super::{
    format_duration_since, format_rate, status_icon, truncate_str, ICON_ACTIVE, ICON_INACTIVE,
};
use anyhow::{Context, Result};
use cratos_skills::{Skill, SkillStatus, SkillStore};

/// List skills
pub async fn list(store: &SkillStore, active_only: bool) -> Result<()> {
    let skills = if active_only {
        store.list_active_skills().await
    } else {
        store.list_skills().await
    }
    .context("Failed to list skills")?;

    let active_count = skills.iter().filter(|s| s.is_active()).count();
    let total = skills.len();

    if skills.is_empty() {
        println!("\nNo skills found.");
        println!("Skills are auto-generated from usage patterns or created manually.\n");
        return Ok(());
    }

    let filter_label = if active_only { " (active only)" } else { "" };
    println!(
        "\nCratos Skills ({} total, {} active){}\n{}",
        total,
        active_count,
        filter_label,
        "-".repeat(56)
    );

    for skill in &skills {
        let icon = status_icon(skill.status);
        let origin_label = match skill.origin {
            cratos_skills::SkillOrigin::AutoGenerated => "auto",
            cratos_skills::SkillOrigin::UserDefined => "user",
            cratos_skills::SkillOrigin::Builtin => "built",
        };
        let rate = format_rate(skill.metadata.success_rate, skill.metadata.usage_count);
        let ago = skill
            .metadata
            .last_used_at
            .map(format_duration_since)
            .unwrap_or_else(|| "never".to_string());
        let disabled_tag = if skill.status == SkillStatus::Disabled {
            " [disabled]"
        } else if skill.status == SkillStatus::Draft {
            " [draft]"
        } else {
            ""
        };

        println!(
            "  {} {:<26} {:<10} {:<6} {:<14} {}{}",
            icon, skill.name, skill.category, origin_label, rate, ago, disabled_tag,
        );
    }

    println!();
    Ok(())
}

/// Show skill details
pub async fn show(store: &SkillStore, name: &str) -> Result<()> {
    let skill = store
        .get_skill_by_name(name)
        .await
        .context("Failed to query skill")?;

    match skill {
        Some(skill) => print_skill_detail(&skill, store).await,
        None => {
            println!("\nSkill not found: {name}");
            println!("Run `cratos skill list` to see available skills.\n");
            Ok(())
        }
    }
}

/// Print detailed skill information
pub async fn print_skill_detail(skill: &Skill, store: &SkillStore) -> Result<()> {
    let icon = status_icon(skill.status);
    let status_label = match skill.status {
        SkillStatus::Active => "Active",
        SkillStatus::Disabled => "Disabled",
        SkillStatus::Draft => "Draft",
    };

    println!("\nSkill: {}\n", skill.name);
    println!("  Status:     {} {}", icon, status_label);
    println!("  Category:   {}", skill.category);
    println!("  Origin:     {}", skill.origin);

    // Triggers
    if !skill.trigger.keywords.is_empty()
        || !skill.trigger.intents.is_empty()
        || !skill.trigger.regex_patterns.is_empty()
    {
        println!("\n  Triggers:");
        if !skill.trigger.keywords.is_empty() {
            println!("    Keywords: {}", skill.trigger.keywords.join(", "));
        }
        if !skill.trigger.intents.is_empty() {
            println!("    Intents:  {}", skill.trigger.intents.join(", "));
        }
        if !skill.trigger.regex_patterns.is_empty() {
            println!("    Patterns: {}", skill.trigger.regex_patterns.join(", "));
        }
    }

    // Steps
    if !skill.steps.is_empty() {
        println!("\n  Steps:");
        for step in &skill.steps {
            let on_err = format!("[{} on error]", step.on_error);
            let input_preview =
                serde_json::to_string(&step.input_template).unwrap_or_else(|_| "{}".to_string());
            let input_short = truncate_str(&input_preview, 40);
            println!(
                "    {}. {:<14} {} {}",
                step.order, step.tool_name, input_short, on_err
            );
        }
    }

    // Metrics
    let (total, successes) = store
        .get_skill_execution_count(skill.id)
        .await
        .unwrap_or((0, 0));
    let rate_pct = if total > 0 {
        (successes as f64 / total as f64) * 100.0
    } else {
        skill.metadata.success_rate * 100.0
    };

    println!("\n  Metrics:");
    println!(
        "    Usage:        {} executions",
        skill.metadata.usage_count
    );
    println!(
        "    Success rate: {:.1}% ({}/{})",
        rate_pct, successes, total
    );
    if let Some(avg_ms) = skill.metadata.avg_duration_ms {
        let avg_secs = avg_ms as f64 / 1000.0;
        println!("    Avg duration: {avg_secs:.1}s");
    }
    let last_used = skill
        .metadata
        .last_used_at
        .map(format_duration_since)
        .unwrap_or_else(|| "never".to_string());
    println!("    Last used:    {last_used}");

    println!();
    Ok(())
}

/// Enable a skill (set status to Active)
pub async fn enable(store: &SkillStore, name: &str) -> Result<()> {
    let skill = store
        .get_skill_by_name(name)
        .await
        .context("Failed to query skill")?;

    match skill {
        Some(mut skill) => {
            if skill.is_active() {
                println!("Skill '{name}' is already active.");
            } else {
                skill.activate();
                store
                    .save_skill(&skill)
                    .await
                    .context("Failed to save skill")?;
                println!("{ICON_ACTIVE} Skill '{name}' enabled.");
            }
            Ok(())
        }
        None => {
            println!("Skill not found: {name}");
            println!("Run `cratos skill list` to see available skills.");
            Ok(())
        }
    }
}

/// Disable a skill
pub async fn disable(store: &SkillStore, name: &str) -> Result<()> {
    let skill = store
        .get_skill_by_name(name)
        .await
        .context("Failed to query skill")?;

    match skill {
        Some(mut skill) => {
            if skill.status == SkillStatus::Disabled {
                println!("Skill '{name}' is already disabled.");
            } else {
                skill.disable();
                store
                    .save_skill(&skill)
                    .await
                    .context("Failed to save skill")?;
                println!("{ICON_INACTIVE} Skill '{name}' disabled.");
            }
            Ok(())
        }
        None => {
            println!("Skill not found: {name}");
            println!("Run `cratos skill list` to see available skills.");
            Ok(())
        }
    }
}
