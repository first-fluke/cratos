//! Skill definitions and types
//!
//! This module defines the core skill types for the auto-generated skill system.
//! Skills are reusable patterns of tool usage that can be triggered by keywords
//! or intents.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use uuid::Uuid;

/// Skill category
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SkillCategory {
    /// Workflow skill (sequence of tools)
    Workflow,
    /// Custom user-defined skill
    Custom,
    /// System built-in skill
    System,
}

impl SkillCategory {
    /// Returns the string representation
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Workflow => "workflow",
            Self::Custom => "custom",
            Self::System => "system",
        }
    }
}

impl std::fmt::Display for SkillCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl std::str::FromStr for SkillCategory {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "workflow" => Ok(Self::Workflow),
            "custom" => Ok(Self::Custom),
            "system" => Ok(Self::System),
            _ => Err(format!("unknown skill category: {s}")),
        }
    }
}

/// Skill origin (how the skill was created)
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SkillOrigin {
    /// Built-in skill
    Builtin,
    /// User-defined skill
    UserDefined,
    /// Auto-generated from detected patterns
    AutoGenerated,
}

impl SkillOrigin {
    /// Returns the string representation
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Builtin => "builtin",
            Self::UserDefined => "user_defined",
            Self::AutoGenerated => "auto_generated",
        }
    }
}

impl std::fmt::Display for SkillOrigin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl std::str::FromStr for SkillOrigin {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "builtin" => Ok(Self::Builtin),
            "user_defined" => Ok(Self::UserDefined),
            "auto_generated" => Ok(Self::AutoGenerated),
            _ => Err(format!("unknown skill origin: {s}")),
        }
    }
}

/// Skill status
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SkillStatus {
    /// Skill is in draft (not active)
    Draft,
    /// Skill is active and can be triggered
    Active,
    /// Skill is disabled
    Disabled,
}

impl SkillStatus {
    /// Returns the string representation
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Draft => "draft",
            Self::Active => "active",
            Self::Disabled => "disabled",
        }
    }
}

impl std::fmt::Display for SkillStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl std::str::FromStr for SkillStatus {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "draft" => Ok(Self::Draft),
            "active" => Ok(Self::Active),
            "disabled" => Ok(Self::Disabled),
            _ => Err(format!("unknown skill status: {s}")),
        }
    }
}

/// Error action for skill steps
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ErrorAction {
    /// Abort the entire skill execution
    Abort,
    /// Continue to the next step
    Continue,
    /// Retry the current step
    Retry,
}

impl ErrorAction {
    /// Returns the string representation
    #[must_use]
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Abort => "abort",
            Self::Continue => "continue",
            Self::Retry => "retry",
        }
    }
}

impl Default for ErrorAction {
    fn default() -> Self {
        Self::Abort
    }
}

impl std::fmt::Display for ErrorAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl std::str::FromStr for ErrorAction {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "abort" => Ok(Self::Abort),
            "continue" => Ok(Self::Continue),
            "retry" => Ok(Self::Retry),
            _ => Err(format!("unknown error action: {s}")),
        }
    }
}

/// A step in a skill execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SkillStep {
    /// Order of execution (1-based)
    pub order: u32,

    /// Tool name to invoke
    pub tool_name: String,

    /// Input template with variable placeholders (e.g., `{{file_path}}`)
    pub input_template: Value,

    /// Action to take on error
    #[serde(default)]
    pub on_error: ErrorAction,

    /// Optional description of what this step does
    pub description: Option<String>,

    /// Maximum retries (for Retry error action)
    #[serde(default)]
    pub max_retries: u32,
}

impl SkillStep {
    /// Create a new skill step
    pub fn new(order: u32, tool_name: impl Into<String>, input_template: Value) -> Self {
        Self {
            order,
            tool_name: tool_name.into(),
            input_template,
            on_error: ErrorAction::default(),
            description: None,
            max_retries: 0,
        }
    }

    /// Set the error action
    #[must_use]
    pub fn with_on_error(mut self, action: ErrorAction) -> Self {
        self.on_error = action;
        self
    }

    /// Set the description
    #[must_use]
    pub fn with_description(mut self, description: impl Into<String>) -> Self {
        self.description = Some(description.into());
        self
    }
}

/// Skill trigger configuration
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct SkillTrigger {
    /// Keywords that can trigger this skill
    pub keywords: Vec<String>,

    /// Regex patterns that can trigger this skill
    pub regex_patterns: Vec<String>,

    /// Intent classifications that can trigger this skill
    pub intents: Vec<String>,

    /// Priority (higher = more preferred when multiple skills match)
    #[serde(default)]
    pub priority: i32,
}

impl SkillTrigger {
    /// Create a new trigger with keywords
    pub fn with_keywords(keywords: Vec<String>) -> Self {
        Self {
            keywords,
            ..Default::default()
        }
    }

    /// Add a keyword
    #[must_use]
    pub fn add_keyword(mut self, keyword: impl Into<String>) -> Self {
        self.keywords.push(keyword.into());
        self
    }

    /// Add a regex pattern
    #[must_use]
    pub fn add_pattern(mut self, pattern: impl Into<String>) -> Self {
        self.regex_patterns.push(pattern.into());
        self
    }

    /// Add an intent
    #[must_use]
    pub fn add_intent(mut self, intent: impl Into<String>) -> Self {
        self.intents.push(intent.into());
        self
    }

    /// Set the priority
    #[must_use]
    pub fn with_priority(mut self, priority: i32) -> Self {
        self.priority = priority;
        self
    }
}

/// Skill metadata for tracking usage and performance
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct SkillMetadata {
    /// Number of times the skill has been used
    pub usage_count: u64,

    /// Success rate (0.0 - 1.0)
    pub success_rate: f64,

    /// Average execution duration in milliseconds
    pub avg_duration_ms: Option<u64>,

    /// Last used timestamp
    pub last_used_at: Option<DateTime<Utc>>,

    /// Source pattern ID (if auto-generated)
    pub source_pattern_id: Option<Uuid>,
}

/// A skill definition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Skill {
    /// Unique identifier
    pub id: Uuid,

    /// Human-readable name
    pub name: String,

    /// Description of what the skill does
    pub description: String,

    /// Category of the skill
    pub category: SkillCategory,

    /// How the skill was created
    pub origin: SkillOrigin,

    /// Current status
    pub status: SkillStatus,

    /// Trigger configuration
    pub trigger: SkillTrigger,

    /// Execution steps
    pub steps: Vec<SkillStep>,

    /// JSON Schema for input validation
    pub input_schema: Option<Value>,

    /// Usage metadata
    pub metadata: SkillMetadata,

    /// When the skill was created
    pub created_at: DateTime<Utc>,

    /// When the skill was last updated
    pub updated_at: DateTime<Utc>,
}

impl Skill {
    /// Create a new skill
    pub fn new(
        name: impl Into<String>,
        description: impl Into<String>,
        category: SkillCategory,
    ) -> Self {
        let now = Utc::now();
        Self {
            id: Uuid::new_v4(),
            name: name.into(),
            description: description.into(),
            category,
            origin: SkillOrigin::UserDefined,
            status: SkillStatus::Draft,
            trigger: SkillTrigger::default(),
            steps: Vec::new(),
            input_schema: None,
            metadata: SkillMetadata::default(),
            created_at: now,
            updated_at: now,
        }
    }

    /// Create an auto-generated skill from a pattern
    pub fn auto_generated(
        name: impl Into<String>,
        description: impl Into<String>,
        source_pattern_id: Uuid,
    ) -> Self {
        let now = Utc::now();
        Self {
            id: Uuid::new_v4(),
            name: name.into(),
            description: description.into(),
            category: SkillCategory::Workflow,
            origin: SkillOrigin::AutoGenerated,
            status: SkillStatus::Draft,
            trigger: SkillTrigger::default(),
            steps: Vec::new(),
            input_schema: None,
            metadata: SkillMetadata {
                source_pattern_id: Some(source_pattern_id),
                success_rate: 1.0,
                ..Default::default()
            },
            created_at: now,
            updated_at: now,
        }
    }

    /// Create a built-in system skill
    pub fn builtin(name: impl Into<String>, description: impl Into<String>) -> Self {
        let now = Utc::now();
        Self {
            id: Uuid::new_v4(),
            name: name.into(),
            description: description.into(),
            category: SkillCategory::System,
            origin: SkillOrigin::Builtin,
            status: SkillStatus::Active,
            trigger: SkillTrigger::default(),
            steps: Vec::new(),
            input_schema: None,
            metadata: SkillMetadata {
                success_rate: 1.0,
                ..Default::default()
            },
            created_at: now,
            updated_at: now,
        }
    }

    /// Set the trigger configuration
    #[must_use]
    pub fn with_trigger(mut self, trigger: SkillTrigger) -> Self {
        self.trigger = trigger;
        self.updated_at = Utc::now();
        self
    }

    /// Add a step to the skill
    #[must_use]
    pub fn with_step(mut self, step: SkillStep) -> Self {
        self.steps.push(step);
        self.updated_at = Utc::now();
        self
    }

    /// Set the steps
    #[must_use]
    pub fn with_steps(mut self, steps: Vec<SkillStep>) -> Self {
        self.steps = steps;
        self.updated_at = Utc::now();
        self
    }

    /// Set the input schema
    #[must_use]
    pub fn with_input_schema(mut self, schema: Value) -> Self {
        self.input_schema = Some(schema);
        self.updated_at = Utc::now();
        self
    }

    /// Activate the skill
    pub fn activate(&mut self) {
        self.status = SkillStatus::Active;
        self.updated_at = Utc::now();
    }

    /// Disable the skill
    pub fn disable(&mut self) {
        self.status = SkillStatus::Disabled;
        self.updated_at = Utc::now();
    }

    /// Check if the skill is active
    #[must_use]
    pub fn is_active(&self) -> bool {
        self.status == SkillStatus::Active
    }

    /// Record a successful execution
    pub fn record_success(&mut self, duration_ms: u64) {
        let count = self.metadata.usage_count;
        let old_rate = self.metadata.success_rate;

        self.metadata.usage_count += 1;
        self.metadata.success_rate = (old_rate * count as f64 + 1.0) / (count + 1) as f64;

        // Update average duration
        if let Some(avg) = self.metadata.avg_duration_ms {
            self.metadata.avg_duration_ms = Some((avg * count + duration_ms) / (count + 1));
        } else {
            self.metadata.avg_duration_ms = Some(duration_ms);
        }

        self.metadata.last_used_at = Some(Utc::now());
        self.updated_at = Utc::now();
    }

    /// Record a failed execution
    pub fn record_failure(&mut self) {
        let count = self.metadata.usage_count;
        let old_rate = self.metadata.success_rate;

        self.metadata.usage_count += 1;
        self.metadata.success_rate = (old_rate * count as f64) / (count + 1) as f64;
        self.metadata.last_used_at = Some(Utc::now());
        self.updated_at = Utc::now();
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_skill_creation() {
        let skill = Skill::new("test_skill", "A test skill", SkillCategory::Custom);

        assert_eq!(skill.name, "test_skill");
        assert_eq!(skill.category, SkillCategory::Custom);
        assert_eq!(skill.origin, SkillOrigin::UserDefined);
        assert_eq!(skill.status, SkillStatus::Draft);
    }

    #[test]
    fn test_skill_auto_generated() {
        let pattern_id = Uuid::new_v4();
        let skill = Skill::auto_generated("auto_skill", "Auto skill", pattern_id);

        assert_eq!(skill.category, SkillCategory::Workflow);
        assert_eq!(skill.origin, SkillOrigin::AutoGenerated);
        assert_eq!(skill.metadata.source_pattern_id, Some(pattern_id));
    }

    #[test]
    fn test_skill_step_creation() {
        let step = SkillStep::new(1, "file_read", serde_json::json!({"path": "{{file_path}}"}))
            .with_on_error(ErrorAction::Continue)
            .with_description("Read a file");

        assert_eq!(step.order, 1);
        assert_eq!(step.tool_name, "file_read");
        assert_eq!(step.on_error, ErrorAction::Continue);
        assert_eq!(step.description, Some("Read a file".to_string()));
    }

    #[test]
    fn test_skill_trigger() {
        let trigger = SkillTrigger::with_keywords(vec!["read".to_string(), "file".to_string()])
            .add_pattern(r"read\s+file")
            .add_intent("file_operation")
            .with_priority(10);

        assert_eq!(trigger.keywords.len(), 2);
        assert_eq!(trigger.regex_patterns.len(), 1);
        assert_eq!(trigger.intents.len(), 1);
        assert_eq!(trigger.priority, 10);
    }

    #[test]
    fn test_skill_activation() {
        let mut skill = Skill::new("test", "test", SkillCategory::Custom);
        assert!(!skill.is_active());

        skill.activate();
        assert!(skill.is_active());

        skill.disable();
        assert!(!skill.is_active());
    }

    #[test]
    fn test_skill_success_tracking() {
        let mut skill = Skill::new("test", "test", SkillCategory::Custom);

        skill.record_success(100);
        assert_eq!(skill.metadata.usage_count, 1);
        assert_eq!(skill.metadata.success_rate, 1.0);
        assert_eq!(skill.metadata.avg_duration_ms, Some(100));

        skill.record_failure();
        assert_eq!(skill.metadata.usage_count, 2);
        assert_eq!(skill.metadata.success_rate, 0.5);
    }

    #[test]
    fn test_category_serialization() {
        let cat = SkillCategory::Workflow;
        let json = serde_json::to_string(&cat).unwrap();
        assert_eq!(json, r#""workflow""#);

        let parsed: SkillCategory = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed, SkillCategory::Workflow);
    }
}
