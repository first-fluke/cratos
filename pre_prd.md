
1) 목적(목표):https://github.com/openclaw/openclaw 를 클로닝하여 더 나은 서비스를 만드는것
1.1 제품 목적
사용자는 Telegram / Slack / Discord 중 어디에서든 자연어로 말하면, 에이전트가:


이해하고(의도 파악)


필요한 정보를 모으고(문서/코드/로그/웹)


실제로 실행하고(툴/코드/명령)


결과를 정리해(요약/근거/다음 행동)

 다시 같은 채널로 보고한다.


비개발자에게는 읽을 것 줄이기/업무 준비 자동화/반복 작업 처리/통제감을 제공하고, 개발자에게는 **원격 개발지시(코딩→테스트→PR)**까지 가능하게 한다.


에이전트가 한 모든 행동은 기록되며, 사용자는 언제든 무슨 일을 했는지 되감기(리플레이)로 확인하거나, 같은 작업을 다시 실행할 수 있다.


승인(Approval)은 사용자의 설정이다. 사용자는 “항상 물어보기 / 위험한 것만 물어보기 / 안 물어보고 바로 실행”을 선택한다.


GPU 없이 운영 가능해야 하며, 비용/속도를 위해 작업별로 적절한 모델을 자동 선택한다.


1.2 해결하려는 문제(사용자 관점)
“알림/스레드/문서가 너무 많아서 뭘 해야 할지 모르겠다”


“회의/업무 준비를 매번 처음부터 정리하느라 시간이 든다”


“반복 작업(정리/요약/리포트/파일관리)이 계속 쌓인다”


“원격으로 ‘이 이슈 고쳐서 PR 올려줘’ 같은 지시를 하고 싶은데, 안전하고 재현 가능하게 하고 싶다”
“원격으로 pc앞에 앉지 않아도 pc로 할수있는 작업을 하고싶다”
“AI가 뭘 했는지 모르겠어서 불안하다 → 기록/되감기가 필요하다”


1.3 성공 기준(예시)
(비개발자) 스레드 요약+할 일 추출, 회의 준비 브리핑, 링크 요약 저장을 설치 직후 10분 내 수행


(개발자) “이 이슈 고쳐서 PR” 요청에 대해: 브랜치 생성→수정→테스트→PR 생성→요약 보고까지 end-to-end 1회 이상 성공


1차 응답(진행/질문/결과) 10초 내 95% 이상


모든 실행은 감사 로그/리플레이 기록이 남아 누락률 0%



2) 상세기획
2.1 시스템이 “자연어”를 처리하는 방식(사용자가 보는 것 vs 내부)
사용자가 보는 것
사용자는 그냥 이렇게 말한다:


“이 스레드 요약해서 해야 할 일만 뽑아줘”


“내일 회의 준비해줘. 질문 리스트랑 자료 링크 정리해줘”


“이 버그 고치고 PR 올려줘”


“CI 깨진 원인 찾아서 고쳐줘”


“방금 한 작업 다시 보여줘(되감기)”


시스템 내부에서 하는 일(사용자는 몰라도 됨)
자연어를 “실행 가능한 계획”으로 변환:


작업 목표


필요한 정보(코드/파일/링크/로그)


사용할 도구(검색/편집/테스트/PR)


위험도 및 승인 필요 여부(설정 기반)


실행 결과를 “보고서”로 정리:


무슨 일을 했는지


무엇이 바뀌었는지


무엇을 확인했는지(테스트/린트)


다음에 무엇을 하면 좋은지



2.2 사용자 경험(UX) 흐름
2.2.1 기본 흐름
사용자가 채널에서 자연어 요청


에이전트 1차 응답(10초 내 목표)


바로 답변 가능 → 즉시 답변


정보 부족 → “필수 질문만 물어봄


실행 필요 → “지금부터 무엇을 할지” 요약 후 실행 시작


실행(여러 단계 가능)


결과 보고(표준 포맷)


기록 저장(리플레이/감사 로그)


2.2.2 승인(Approval) 흐름 — 설정 기반
always: 어떤 도구든 실행 전에 확인


risky_only: 파일 변경/외부 전송/코드 푸시/PR 생성 등 위험 작업만 확인


never: 묻지 않고 바로 실행


승인 요청 메시지는 반드시 포함:


작업 요약(무엇)


영향 범위(무엇이 바뀜)


실행할 내용(가능하면 diff/명령)


선택(승인/취소/수정)


2.2.3 되감기(리플레이) 흐름
“방금 한 거 뭐였지?”, “실행 과정 다시 보여줘”, “실패한 이유 뭐야?”


타임라인 형태로:


입력 → 계획 → 도구 호출 → 결과 → 최종 답변


재실행 모드:


보기만(재현)


같은 입력으로 재실행


안전 모드(dry-run: 실제 변경 없이 계획/검증만)



2.3 핵심 기능 시나리오
2.3.1 인박스/스레드 정리(비개발자 핵심)
입력: “오늘 중요한 것만 요약해줘”, “이 스레드 핵심만”, “답장 초안 써줘”


출력: 핵심 요약 + 해야 할 일 + 답장 초안 + 출처 링크


2.3.2 회의/업무 준비(비개발자 핵심)
입력: “내일 회의 준비해줘”, “이 문서 보고 요약해줘”


출력: 준비 브리핑(안건/질문/리스크/자료)


2.3.3 개인 업무 자동화(비개발자 핵심)
입력: “이 링크 요약해서 노트로 저장해줘”, “파일 정리해줘”


출력: 생성된 산출물(파일/요약) + 변경 목록


2.3.4 원격 개발지시(개발자 핵심)
사용자는 자연어로만 요청한다. 예:
“이 GitHub 이슈 #123 해결해서 PR 만들어줘”


“이 PR 리뷰 코멘트 반영해줘”


“테스트 깨지는 거 고쳐줘”


“로그 보고 원인 후보 3개 뽑고 수정까지 해줘”


에이전트는 내부적으로 아래 단계를 표준화한다(사용자는 결과만 받음):
레포 준비(클론/동기화/브랜치 생성)


코드 탐색(검색/읽기)


수정(패치 적용)


검증(테스트/린트/타입체크)


커밋(메시지 규칙 적용)


푸시 + PR 생성


요약 보고(변경점/리스크/테스트 결과/PR 링크)


중요: 사용자가 “PR까지 올려줘”라고 말했는데 권한이 없으면, 에이전트는:
필요한 권한을 요청하거나(설정 안내)


PR 생성 직전까지 준비하고 diff/커밋을 제공한 뒤 “여기까지 완료, 푸시는 사용자가 실행”으로 전환할 수 있어야 함.



2.4 차별화(비개발자도 체감)
되감기(리플레이): AI가 한 모든 행동이 타임라인으로 남는다 → “불안함 감소”


바로 쓰는 기본 루틴: 별도 학습 없이 “요약/회의 준비/정리/개발 PR”이 된다


안 되는 이유를 스스로 진단: 권한/연동/네트워크 문제를 체크리스트로 안내


비용 최적화: 필요한 때만 강한 모델 사용(사용자는 몰라도 됨)


안전한 기본값: 위험한 행동/민감정보 노출을 줄이는 가드레일





3) 기능요구사항(Functional Requirements)
3.1 채널 연동
Telegram/Slack/Discord에서 메시지를 수신할 수 있어야 한다.


DM/채널/스레드(가능한 범위)를 구분하고 동일 세션으로 매핑해야 한다.


메시지를 표준 이벤트로 정규화해야 한다:


channel, workspace/server, user_id, thread_id, message_id, timestamp, text, attachments


응답은 원 요청의 스레드/리플라이 컨텍스트를 유지하여 전송해야 한다.


레이트리밋 준수 및 전송 재시도/백오프가 있어야 한다.


3.2 자연어 이해 및 실행 루프
시스템은 자연어 입력을 “실행 계획”으로 변환해야 한다(목표/단계/도구).


정보가 부족하면 최대 1~3개 질문으로 보완해야 한다.


멀티스텝 실행을 지원해야 한다(도구 호출 → 결과 → 다음 단계).


실행 단계 수/시간/비용에 대한 budget 제한을 제공해야 한다.


3.3 LLM 연동 및 모델 라우팅
LLM 제공자/모델은 설정으로 교체 가능해야 한다.


작업 유형별 모델 자동 선택을 지원해야 한다:
분류/짧은 요약(저비용) / 계획 수립(고성능) / 최종 문장 다듬기(중간)


LLM 출력은 도구 호출을 위해 구조화된 포맷(JSON schema/함수 호출)만 허용해야 한다.


스키마 위반 시 자동 교정 재시도를 수행해야 한다.


3.4 메모리/컨텍스트
세션 키 (channel, workspace, user, thread)로 컨텍스트를 유지해야 한다.


Session Memory(최근 N턴) 저장이 있어야 한다.


Working Memory(요약 압축) 자동 생성/갱신이 있어야 한다.


Long-term Memory(선호/루틴/중요 정보) 저장/조회(옵션)를 지원해야 한다.


사용자가 “새 작업 시작”을 선언하면 컨텍스트를 분리해야 한다.


3.5 도구(툴) 시스템
Tool Registry를 제공하고, 각 도구는 다음을 포함해야 한다:


name, description, input_schema, output_schema, risk_level(read/write/destructive),

 required_scopes, timeout, retry_policy


Tool Runner는 도구 실행을 표준 결과로 반환해야 한다(성공/실패/에러 타입).


최소 제공 도구(초기):


파일: list/read/write/move/rename/copy/delete(정책으로 제한 가능)


시스템: 제한 exec(allowlist) + 환경 조회


네트워크: HTTP GET/POST


웹: 콘텐츠 fetch + 텍스트 추출


문서: markdown 생성/저장


3.6 승인(Approval) — 설정 기반
사용자는 always | risky_only | never 승인 모드를 설정할 수 있어야 한다.


채널별/도구별 오버라이드를 설정할 수 있어야 한다.


승인 요청 메시지는 작업 요약/영향/실행 내용/선택지를 포함해야 한다.


3.7 되감기(Agent Replay)
모든 실행은 리플레이 가능한 이벤트 로그로 저장되어야 한다:


입력, 계획 요약, LLM 출력, 도구 호출/결과, 최종 응답


사용자는 채팅에서 “마지막 실행/특정 실행” 리플레이를 요청할 수 있어야 한다.


리플레이는 보기 전용/동일 입력 재실행/dry-run 모드를 지원해야 한다.


3.8 자기 진단(Tool Doctor)
주요 실패 유형(권한/토큰/네트워크/레이트리밋/경로 오류)을 진단해야 한다.


진단 결과를 “원인 후보 + 해결 체크리스트”로 제공해야 한다.


사용자가 “왜 안 돼?”라고 하면 진단을 트리거할 수 있어야 한다(옵션: 자동 트리거).


3.9 원격 개발지시(핵심 기능)
레포지토리 작업을 위한 개발 도구 세트를 제공해야 한다:


Git: clone/fetch/checkout/branch/status/diff/commit/push


코드 탐색: search/read/list


코드 수정: apply_patch/write_file


품질 검증: test/lint/typecheck 실행 + 결과 요약


GitHub 연동(또는 일반 Git 원격): PR 생성/코멘트/CI 상태 조회(가능한 범위)


사용자의 자연어 요청을 “개발 작업 플랜”으로 변환해야 한다:


목표(이슈 해결/리팩터/버그 수정)


변경 범위(파일/모듈)


검증 계획(테스트/린트)


산출물(PR/패치/커밋)


실행 결과는 표준 리포트로 제공해야 한다:


변경 요약, 파일별 diff 핵심, 테스트 결과, 리스크, PR 링크


권한 부족/정책 제한 시 안전한 대체 경로를 제공해야 한다:


PR 직전까지 준비 후 diff/커밋 제공


권한 설정 안내


3. 비밀정보가 커밋/PR/로그에 포함되지 않도록 자동 검사(마스킹/스캔)를 수행해야 한다.


3.10 감사 로그/조회
모든 도구 실행은 감사 로그로 기록되어야 한다(누가/언제/무엇/결과).


사용자는 채팅에서 최근 실행 내역 조회가 가능해야 한다.


민감정보는 로그/리포트에서 마스킹되어야 한다.



4) 비기능요구사항(Non-functional Requirements)
4.1 보안(Security) — “승인은 옵션, 안전은 기본”
기본 네트워크 노출은 최소화(로컬 바인딩 기본)하고 외부 노출 시 인증이 필수다.


Slack 서명 검증 등 채널별 검증을 정확히 수행해야 한다.


사용자/워크스페이스 allowlist를 지원해야 한다.


도구는 required_scopes로 최소 권한을 강제해야 한다.


도구 실행은 가능하면 권한 분리/샌드박스 실행을 지원해야 한다.


민감정보는 안전한 저장소에 보관하고 로그/응답에서 마스킹한다.


원격 개발 기능은 다음을 기본으로 막거나 제한해야 한다:


force push, 대량 삭제, 비인가 레포 접근(정책으로만 해제 가능)


“위험 설정 조합”을 감지해 경고해야 한다:


approval=never + destructive 허용 + 외부 노출 등


4.2 신뢰성(Reliability)
메시지 수신/전송은 재시도/백오프를 제공해야 한다.


중복 이벤트로 동일 작업이 반복 실행되지 않도록 멱등 처리가 필요하다.


도구 실행은 타임아웃/중단이 가능해야 한다.


부분 실패 시 대안/수동 조치 가이드를 제공해야 한다.


4.3 성능(Performance)
1차 응답(진행/질문)은 10초 내 제공(95%)을 목표로 한다.


일반 실행 결과는 60초 내 제공을 목표로 한다(외부 API 지연 제외).


동시 세션(50~200)을 고려한 비동기/큐 기반 처리를 지원해야 한다.


4.4 관측 가능성(Observability)
구조화 로그(JSON) + trace_id로 입력→LLM→도구→응답을 연결해야 한다.


메트릭 수집:


LLM 토큰/비용/지연


도구 성공률/지연/에러 유형


채널별 처리량


실패 케이스는 리플레이 가능한 형태로 보존해야 한다.


4.5 유지보수성/확장성(Maintainability)
채널 어댑터/LLM 제공자/도구는 플러그인 형태로 교체 가능해야 한다.


표준 이벤트/도구 스키마는 버저닝되어야 하며 변경 전략이 필요하다.


원격 개발 도구는 프로젝트별 커맨드(테스트/린트)를 설정으로 교체 가능해야 한다.


4.6 비용/운영(Cost & Ops)
모델 라우팅으로 평균 비용을 제어할 수 있어야 한다.


실행 단위별 비용/사용량 리포트를 제공할 수 있어야 한다(옵션).


CPU-only 환경에서 안정적으로 운영 가능해야 한다.




